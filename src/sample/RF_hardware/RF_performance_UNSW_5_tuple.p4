########################################################################
# THIS FILE IS PART OF Planter PROJECT
# Copyright (c) Changgang Zheng and Computing Infrastructure Group
# Departement of Engineering Science, University of Oxford
# All rights reserved.
# E-mail: changgang.zheng@eng.ox.ac.uk or changgangzheng@qq.com
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at :
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#########################################################################
# This file was autogenerated

/*
 * Planter
 *
 * This program implements a simple protocol. It can be carried over Ethernet
 * (Ethertype 0x1234).
 *
 * The Protocol header looks like this:
 *
 *        0                1                  2              3
 * +----------------+----------------+----------------+---------------+
 * |      P         |       4        |     Version    |     Type      |
 * +----------------+----------------+----------------+---------------+
 * |                              feature0                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature1                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature2                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature3                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature4                            |
 * +----------------+----------------+----------------+---------------+
 * |                              Result                              |
 * +----------------+----------------+----------------+---------------+
 *
 * P is an ASCII Letter 'P' (0x50)
 * 4 is an ASCII Letter '4' (0x34)
 * Version is currently 1 (0x01)
 * Type is currently 1 (0x01)
 *
 * The device receives a packet, do the classification, fills in the
 * result and sends the packet back out of the same port it came in on, while
 * swapping the source and destination addresses.
 *
 * If an unknown operation is specified or the header is not valid, the packet
 * is dropped
 */

#include <core.p4>
#include <tna.p4>

/*************************************************************************
*********************** headers and metadata******************************
*************************************************************************/

const bit<16> ETHERTYPE_Planter = 0x1234;
const bit<8>  Planter_P     = 0x50;   // 'P'
const bit<8>  Planter_4     = 0x34;   // '4'
const bit<8>  Planter_VER   = 0x01;   // v0.1

header ethernet_h {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header Planter_h{
    bit<8> p;
    bit<8> four;
    bit<8> ver;
    bit<8> typ;
    bit<32> feature0;
    bit<32> feature1;
    bit<32> feature2;
    bit<32> feature3;
    bit<32> feature4;
    bit<32> result;
}

struct header_t {
    ethernet_h   ethernet;
    Planter_h    Planter;
}

struct metadata_t {
    bit<39> code_f0;
    bit<43> code_f1;
    bit<20> code_f2;
    bit<22> code_f3;
    bit<11> code_f4;
    bit<7> sum_prob;
    bit<4> tree_0_vote;
    bit<4> tree_1_vote;
    bit<4> tree_2_vote;
    bit<4> tree_3_vote;
    bit<4> tree_4_vote;
    bit<4> tree_5_vote;
    bit<4> tree_6_vote;
    bit<4> tree_7_vote;
    bit<4> tree_8_vote;
    bit<4> tree_9_vote;
    bit<32>  DstAddr;
    bit<32> feature0;
    bit<32> feature1;
    bit<32> feature2;
    bit<32> feature3;
    bit<32> feature4;
    bit<32> result;
    bit<8> flag ;
}

/*************************************************************************
*********************** Ingress Parser ***********************************
*************************************************************************/

parser SwitchIngressParser(
    packet_in pkt,
    out header_t hdr,
    out metadata_t meta,
    out ingress_intrinsic_metadata_t ig_intr_md) {

    state start {
        pkt.extract(ig_intr_md);
        pkt.advance(PORT_METADATA_SIZE);
        transition parse_ethernet;
    }

    state parse_ethernet {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
        ETHERTYPE_Planter : check_planter_version;
        default           : accept;
        }
    }

    state check_planter_version {
        transition select(pkt.lookahead<Planter_h>().p,
                          pkt.lookahead<Planter_h>().four,
                          pkt.lookahead<Planter_h>().ver) {
        (Planter_P, Planter_4, Planter_VER) : parse_planter;
        default                             : accept;
        }
    }

    state parse_planter {
        pkt.extract(hdr.Planter);
        meta.feature0 = hdr.Planter.feature0;
        meta.feature1 = hdr.Planter.feature1;
        meta.feature2 = hdr.Planter.feature2;
        meta.feature3 = hdr.Planter.feature3;
        meta.feature4 = hdr.Planter.feature4;
        meta.flag = 1 ;
        transition accept;
    }
}

/*************************************************************************
*********************** Ingress Deparser *********************************
**************************************************************************/

control SwitchIngressDeparser(
    packet_out pkt,
    inout header_t hdr,
    in metadata_t ig_md,
    in ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md) {
    apply {
        pkt.emit(hdr);
    }
}

/*************************************************************************
*********************** Egress Parser ***********************************
*************************************************************************/

parser SwitchEgressParser(
    packet_in pkt,
    out header_t hdr,
    out metadata_t meta,
    out egress_intrinsic_metadata_t eg_intr_md) {
    state start {
        pkt.extract(eg_intr_md);
        transition accept;
        }

}

/*************************************************************************
*********************** Egress Deparser *********************************
**************************************************************************/

control SwitchEgressDeparser(
    packet_out pkt,
    inout header_t hdr,
    in metadata_t eg_md,
    in egress_intrinsic_metadata_for_deparser_t eg_dprsr_md) {
    apply {
        pkt.emit(hdr);
    }
}

/*************************************************************************
*********************** Ingress Processing********************************
**************************************************************************/

control SwitchIngress(
    inout header_t hdr,
    inout metadata_t meta,
    in ingress_intrinsic_metadata_t ig_intr_md,
    in ingress_intrinsic_metadata_from_parser_t ig_prsr_md,
    inout ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md,
    inout ingress_intrinsic_metadata_for_tm_t ig_tm_md) {

    // dependency marker @!slice, 0!@  @!position, control!@
    action drop() {
        ig_dprsr_md.drop_ctl = 0x1;
    }

    action send(PortId_t port) {
        ig_tm_md.ucast_egress_port = port;
    }

    action extract_feature0(out bit<39> meta_code, bit<39> tree){
        meta_code = tree;
    }

    action extract_feature1(out bit<43> meta_code, bit<43> tree){
        meta_code = tree;
    }

    action extract_feature2(out bit<20> meta_code, bit<20> tree){
        meta_code = tree;
    }

    action extract_feature3(out bit<22> meta_code, bit<22> tree){
        meta_code = tree;
    }

    action extract_feature4(out bit<11> meta_code, bit<11> tree){
        meta_code = tree;
    }

    @pragma stage 0
    table lookup_feature0 {
        key = { hdr.Planter.feature0:ternary; }
        actions = {
            extract_feature0(meta.code_f0);
            NoAction;
            }
        size = 222;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature1 {
        key = { hdr.Planter.feature1:ternary; }
        actions = {
            extract_feature1(meta.code_f1);
            NoAction;
            }
        size = 200;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature2 {
        key = { hdr.Planter.feature2:ternary; }
        actions = {
            extract_feature2(meta.code_f2);
            NoAction;
            }
        size = 7;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature3 {
        key = { hdr.Planter.feature3:ternary; }
        actions = {
            extract_feature3(meta.code_f3);
            NoAction;
            }
        size = 14;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature4 {
        key = { hdr.Planter.feature4:ternary; }
        actions = {
            extract_feature4(meta.code_f4);
            NoAction;
            }
        size = 13;
        default_action = NoAction;
    }


    action read_prob0(bit<7> prob, bit<4> vote){
        meta.tree_0_vote = vote;
    }
    action write_default_class0() {
        meta.tree_0_vote = 0;
    }


    action read_prob1(bit<7> prob, bit<4> vote){
        meta.tree_1_vote = vote;
    }
    action write_default_class1() {
        meta.tree_1_vote = 0;
    }


    action read_prob2(bit<7> prob, bit<4> vote){
        meta.tree_2_vote = vote;
    }
    action write_default_class2() {
        meta.tree_2_vote = 0;
    }


    action read_prob3(bit<7> prob, bit<4> vote){
        meta.tree_3_vote = vote;
    }
    action write_default_class3() {
        meta.tree_3_vote = 0;
    }


    action read_prob4(bit<7> prob, bit<4> vote){
        meta.tree_4_vote = vote;
    }
    action write_default_class4() {
        meta.tree_4_vote = 0;
    }


    action read_prob5(bit<7> prob, bit<4> vote){
        meta.tree_5_vote = vote;
    }
    action write_default_class5() {
        meta.tree_5_vote = 0;
    }


    action read_prob6(bit<7> prob, bit<4> vote){
        meta.tree_6_vote = vote;
    }
    action write_default_class6() {
        meta.tree_6_vote = 0;
    }


    action read_prob7(bit<7> prob, bit<4> vote){
        meta.tree_7_vote = vote;
    }
    action write_default_class7() {
        meta.tree_7_vote = 0;
    }


    action read_prob8(bit<7> prob, bit<4> vote){
        meta.tree_8_vote = vote;
    }
    action write_default_class8() {
        meta.tree_8_vote = 0;
    }


    action read_prob9(bit<7> prob, bit<4> vote){
        meta.tree_9_vote = vote;
    }
    action write_default_class9() {
        meta.tree_9_vote = 0;
    }

    @pragma stage 1
    table lookup_leaf_id0 {
        key = { meta.code_f0[3:0]:exact;
                meta.code_f1[3:0]:exact;
                meta.code_f2[1:0]:exact;
                meta.code_f3[1:0]:exact;
                meta.code_f4[0:0]:exact;
                }
        actions={
            read_prob0;
            write_default_class0;
        }
        size = 84;
        default_action = write_default_class0;
    }

    @pragma stage 1
    table lookup_leaf_id1 {
        key = { meta.code_f0[6:4]:exact;
                meta.code_f1[7:4]:exact;
                meta.code_f2[3:2]:exact;
                meta.code_f3[3:2]:exact;
                meta.code_f4[2:1]:exact;
                }
        actions={
            read_prob1;
            write_default_class1;
        }
        size = 61;
        default_action = write_default_class1;
    }

    @pragma stage 1
    table lookup_leaf_id2 {
        key = { meta.code_f0[10:7]:exact;
                meta.code_f1[12:8]:exact;
                meta.code_f2[5:4]:exact;
                meta.code_f3[5:4]:exact;
                meta.code_f4[3:3]:exact;
                }
        actions={
            read_prob2;
            write_default_class2;
        }
        size = 87;
        default_action = write_default_class2;
    }

    @pragma stage 1
    table lookup_leaf_id3 {
        key = { meta.code_f0[14:11]:exact;
                meta.code_f1[16:13]:exact;
                meta.code_f2[7:6]:exact;
                meta.code_f3[7:6]:exact;
                meta.code_f4[4:4]:exact;
                }
        actions={
            read_prob3;
            write_default_class3;
        }
        size = 61;
        default_action = write_default_class3;
    }

    @pragma stage 1
    table lookup_leaf_id4 {
        key = { meta.code_f0[19:15]:exact;
                meta.code_f1[21:17]:exact;
                meta.code_f2[9:8]:exact;
                meta.code_f3[10:8]:exact;
                meta.code_f4[5:5]:exact;
                }
        actions={
            read_prob4;
            write_default_class4;
        }
        size = 181;
        default_action = write_default_class4;
    }

    @pragma stage 1
    table lookup_leaf_id5 {
        key = { meta.code_f0[23:20]:exact;
                meta.code_f1[25:22]:exact;
                meta.code_f2[11:10]:exact;
                meta.code_f3[12:11]:exact;
                meta.code_f4[6:6]:exact;
                }
        actions={
            read_prob5;
            write_default_class5;
        }
        size = 57;
        default_action = write_default_class5;
    }

    @pragma stage 1
    table lookup_leaf_id6 {
        key = { meta.code_f0[27:24]:exact;
                meta.code_f1[28:26]:exact;
                meta.code_f2[13:12]:exact;
                meta.code_f3[14:13]:exact;
                meta.code_f4[7:7]:exact;
                }
        actions={
            read_prob6;
            write_default_class6;
        }
        size = 38;
        default_action = write_default_class6;
    }

    @pragma stage 1
    table lookup_leaf_id7 {
        key = { meta.code_f0[30:28]:exact;
                meta.code_f1[33:29]:exact;
                meta.code_f2[15:14]:exact;
                meta.code_f3[17:15]:exact;
                meta.code_f4[8:8]:exact;
                }
        actions={
            read_prob7;
            write_default_class7;
        }
        size = 39;
        default_action = write_default_class7;
    }

    @pragma stage 1
    table lookup_leaf_id8 {
        key = { meta.code_f0[33:31]:exact;
                meta.code_f1[38:34]:exact;
                meta.code_f2[17:16]:exact;
                meta.code_f3[19:18]:exact;
                meta.code_f4[9:9]:exact;
                }
        actions={
            read_prob8;
            write_default_class8;
        }
        size = 61;
        default_action = write_default_class8;
    }

    @pragma stage 1
    table lookup_leaf_id9 {
        key = { meta.code_f0[38:34]:exact;
                meta.code_f1[42:39]:exact;
                meta.code_f2[19:18]:exact;
                meta.code_f3[21:20]:exact;
                meta.code_f4[10:10]:exact;
                }
        actions={
            read_prob9;
            write_default_class9;
        }
        size = 66;
        default_action = write_default_class9;
    }

    // dependency marker @!end,0!@




    // dependency marker @!slice, 1!@  @!position, control!@


    action read_lable(bit<32> label){
        hdr.Planter.result = label;
    }

    action write_default_decision() {
        hdr.Planter.result = 0;
    }

    table decision {
        key = { meta.tree_0_vote:exact;
                meta.tree_1_vote:exact;
                meta.tree_2_vote:exact;
                meta.tree_3_vote:exact;
                meta.tree_4_vote:exact;
                meta.tree_5_vote:exact;
                meta.tree_6_vote:exact;
                meta.tree_7_vote:exact;
                meta.tree_8_vote:exact;
                meta.tree_9_vote:exact;
                }
        actions={
            read_lable;
            write_default_decision;
        }
        size = 386;
        default_action = write_default_decision;
    }
    // dependency marker @!end,1!@

    apply{
       // dependency marker @!slice,0!@ @!previous,none!@ @!position, control-apply!@
        // resource marker @!stage, 5!@ @!memory, 5!@
        // p4 marker @!metadata_in, bit<32>, feature0!@ @!metadata_in, bit<32>, feature1!@ @!metadata_in, bit<32>, feature2!@ @!metadata_in, bit<32>, feature3!@ @!metadata_in, bit<32>, feature4!@ @!metadata_in, bit<39>, code_f0!@ @!metadata_in, bit<43>, code_f1!@ @!metadata_in, bit<20>, code_f2!@ @!metadata_in, bit<22>, code_f3!@ @!metadata_in, bit<11>, code_f4!@
        // p4 marker @!metadata_out, bit<4>, tree_0_vote!@ @!metadata_out, bit<4>, tree_1_vote!@ @!metadata_out, bit<4>, tree_2_vote!@ @!metadata_out, bit<4>, tree_3_vote!@ @!metadata_out, bit<4>, tree_4_vote!@ @!metadata_out, bit<4>, tree_5_vote!@ @!metadata_out, bit<4>, tree_6_vote!@ @!metadata_out, bit<4>, tree_7_vote!@ @!metadata_out, bit<4>, tree_8_vote!@ @!metadata_out, bit<4>, tree_9_vote!@
        lookup_feature0.apply();
        lookup_feature1.apply();
        lookup_feature2.apply();
        lookup_feature3.apply();
        lookup_feature4.apply();
        lookup_leaf_id0.apply();
        lookup_leaf_id1.apply();
        lookup_leaf_id2.apply();
        lookup_leaf_id3.apply();
        lookup_leaf_id4.apply();
        lookup_leaf_id5.apply();
        lookup_leaf_id6.apply();
        lookup_leaf_id7.apply();
        lookup_leaf_id8.apply();
        lookup_leaf_id9.apply();
        // dependency marker @!end,10!@



        // dependency marker @!slice,1!@ @!previous,0!@ @!position, control-apply!@
        // resource marker @!stage, 5!@ @!memory, 5!@
        // p4 marker @!metadata_in, bit<4>, tree_0_vote!@ @!metadata_in, bit<4>, tree_1_vote!@ @!metadata_in, bit<4>, tree_2_vote!@ @!metadata_in, bit<4>, tree_3_vote!@ @!metadata_in, bit<4>, tree_4_vote!@ @!metadata_in, bit<4>, tree_5_vote!@ @!metadata_in, bit<4>, tree_6_vote!@ @!metadata_in, bit<4>, tree_7_vote!@ @!metadata_in, bit<4>, tree_8_vote!@ @!metadata_in, bit<4>, tree_9_vote!@
        // p4 marker @!metadata_out, bit<32>, result!@
        decision.apply();
        // dependency marker @!end,1!@
        send(ig_intr_md.ingress_port);
    }
}
/*************************************************************************
*********************** egress Processing********************************
**************************************************************************/

control SwitchEgress(inout header_t hdr,
    inout metadata_t meta,
    in egress_intrinsic_metadata_t eg_intr_md,
    in egress_intrinsic_metadata_from_parser_t eg_prsr_md,
    inout egress_intrinsic_metadata_for_deparser_t     eg_dprsr_md,
    inout egress_intrinsic_metadata_for_output_port_t  eg_oport_md) {

    action drop() {
        eg_dprsr_md.drop_ctl = 0x1;
    }

    apply {
    }
}
/*************************************************************************
***********************  S W I T C H  ************************************
*************************************************************************/

Pipeline(SwitchIngressParser(),
    SwitchIngress(),
    SwitchIngressDeparser(),
    SwitchEgressParser(),
    SwitchEgress(),
    SwitchEgressDeparser()) pipe;

Switch(pipe) main;